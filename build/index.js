// Generated by CoffeeScript 1.10.0
var configure,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

configure = function(dependencies) {
  var Bluebird, BocoKnexRDB, Cursor, DataMapper, DataMapperObjectSourceMap, DataMapperRecordSourceMap, ObjectSourceMap, TableGateway, TransformStream, WritableStream, camelCase, snakeCase;
  if (dependencies == null) {
    dependencies = {};
  }
  snakeCase = dependencies.snakeCase, camelCase = dependencies.camelCase, ObjectSourceMap = dependencies.ObjectSourceMap, Bluebird = dependencies.Bluebird, WritableStream = dependencies.WritableStream, TransformStream = dependencies.TransformStream;
  if (typeof require === 'function') {
    if (snakeCase == null) {
      snakeCase = require('lodash').snakeCase;
    }
    if (camelCase == null) {
      camelCase = require('lodash').camelCase;
    }
    if (ObjectSourceMap == null) {
      ObjectSourceMap = require('boco-object-source-map').ObjectSourceMap;
    }
    if (Bluebird == null) {
      Bluebird = require("bluebird");
    }
    if (TransformStream == null) {
      TransformStream = require("stream").Transform;
    }
    if (WritableStream == null) {
      WritableStream = require("stream").Writable;
    }
  }
  DataMapperObjectSourceMap = (function(superClass) {
    extend(DataMapperObjectSourceMap, superClass);

    function DataMapperObjectSourceMap() {
      return DataMapperObjectSourceMap.__super__.constructor.apply(this, arguments);
    }

    DataMapperObjectSourceMap.prototype.defaultResolver = function(source, key) {
      return source[snakeCase(key)];
    };

    return DataMapperObjectSourceMap;

  })(ObjectSourceMap);
  DataMapperRecordSourceMap = (function(superClass) {
    extend(DataMapperRecordSourceMap, superClass);

    function DataMapperRecordSourceMap() {
      return DataMapperRecordSourceMap.__super__.constructor.apply(this, arguments);
    }

    DataMapperRecordSourceMap.prototype.defaultResolver = function(source, key) {
      return source[camelCase(key)];
    };

    return DataMapperRecordSourceMap;

  })(ObjectSourceMap);
  TableGateway = (function() {
    TableGateway.prototype.table = null;

    TableGateway.prototype.knex = null;

    function TableGateway(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
    }

    TableGateway.prototype.createIdentityParameters = function(identifier) {
      if (typeof identifier !== 'object') {
        return {
          id: identifier
        };
      }
      return {
        id: identifier.id
      };
    };

    TableGateway.prototype.executeQuery = function() {
      var args, done, i, query;
      query = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      return Bluebird["try"](function() {
        var ref, transaction;
        if (args.length) {
          transaction = ((ref = args[0][0]) != null ? ref : {}).transaction;
        }
        if (transaction != null) {
          query = query.transacting(transaction);
        }
        return query;
      }).done(done.bind(null, null), done);
    };

    TableGateway.prototype.createCursor = function() {
      var args, done, i, query, ref, transaction;
      query = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      if (args.length) {
        transaction = ((ref = args[0][0]) != null ? ref : {}).transaction;
      }
      if (transaction != null) {
        query = query.transacting(transaction);
      }
      return new Cursor({
        stream: query.stream()
      });
    };

    TableGateway.prototype.insert = function() {
      var args, done, i, query, record;
      record = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      query = this.knex(this.table).insert(record);
      return this.executeQuery.apply(this, [query].concat(slice.call(args), [function(error, insertedIds) {
        if (error != null) {
          return done(error);
        }
        return done(null, insertedIds[0]);
      }]));
    };

    TableGateway.prototype.update = function() {
      var args, done, i, identifier, identityParameters, parameters, query;
      identifier = arguments[0], parameters = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), done = arguments[i++];
      identityParameters = this.createIdentityParameters(identifier);
      query = this.knex(this.table).where(identityParameters).update(parameters);
      return this.executeQuery.apply(this, [query].concat(slice.call(args), [function(error, updatedRecordsCount) {
        if (error != null) {
          return done(error);
        }
        if (updatedRecordsCount === 0) {
          return done("no rows updated");
        }
        return done(null, updatedRecordsCount);
      }]));
    };

    TableGateway.prototype.remove = function() {
      var args, done, i, identifier, identityParameters, query;
      identifier = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      identityParameters = this.createIdentityParameters(identifier);
      query = this.knex(this.table).where(identityParameters).del();
      return this.executeQuery.apply(this, [query].concat(slice.call(args), [function(error, removedRecordsCount) {
        if (error != null) {
          return done(error);
        }
        if (removedRecordsCount === 0) {
          return done("record not removed");
        }
        return done(null, removedRecordsCount);
      }]));
    };

    TableGateway.prototype.read = function() {
      var args, done, i, identifier, identityParameters, query;
      identifier = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      identityParameters = this.createIdentityParameters(identifier);
      query = this.knex(this.table).where(identityParameters).first();
      return this.executeQuery.apply(this, [query].concat(slice.call(args), [done]));
    };

    TableGateway.prototype.all = function() {
      var args, query;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      query = this.knex(this.table).select('*');
      return this.createCursor.apply(this, [query].concat(slice.call(args)));
    };

    return TableGateway;

  })();
  DataMapper = (function() {
    DataMapper.prototype.objectSourceMap = null;

    DataMapper.prototype.recordSourceMap = null;

    DataMapper.prototype.tableGateway = null;

    function DataMapper(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.objectSourceMap == null) {
        this.objectSourceMap = new DataMapperObjectSourceMap();
      }
      if (this.recordSourceMap == null) {
        this.recordSourceMap = new DataMapperRecordSourceMap();
      }
    }

    DataMapper.prototype.defineObjectSourceMap = function(definition) {
      return this.objectSourceMap.define(definition);
    };

    DataMapper.prototype.defineRecordSourceMap = function(definition) {
      return this.recordSourceMap.define(definition);
    };

    DataMapper.prototype.constructObject = function(properties) {
      return properties;
    };

    DataMapper.prototype.constructRecord = function(properties) {
      return properties;
    };

    DataMapper.prototype.convertRecord = function(record) {
      var properties;
      properties = this.objectSourceMap.resolve(record);
      return this.constructObject(properties);
    };

    DataMapper.prototype.convertObject = function(object) {
      var properties;
      properties = this.recordSourceMap.resolve(object);
      return this.constructRecord(properties);
    };

    DataMapper.prototype.convertObjectParameters = function(parameters) {
      var key, val;
      parameters = this.recordSourceMap.resolve(parameters);
      for (key in parameters) {
        if (!hasProp.call(parameters, key)) continue;
        val = parameters[key];
        if (val === void 0) {
          delete parameters[key];
        }
      }
      return parameters;
    };

    DataMapper.prototype.convertObjectIdentifier = function(identifier) {
      if (typeof identifier !== 'object') {
        return identifier;
      }
      return this.convertObjectParameters(identifier);
    };

    DataMapper.prototype.createTransformStream = function() {
      var convertRecord, transform;
      convertRecord = this.convertRecord.bind(this);
      transform = function(record, _, done) {
        return done(null, convertRecord(record));
      };
      return new TransformStream({
        objectMode: true,
        transform: transform
      });
    };

    DataMapper.prototype.insert = function() {
      var args, done, i, object, record, ref;
      object = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      record = this.convertObject(object);
      return (ref = this.tableGateway).insert.apply(ref, [record].concat(slice.call(args), [done]));
    };

    DataMapper.prototype.update = function() {
      var args, done, i, identifier, parameters, ref;
      identifier = arguments[0], parameters = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), done = arguments[i++];
      identifier = this.convertObjectIdentifier(identifier);
      parameters = this.convertObjectParameters(parameters);
      return (ref = this.tableGateway).update.apply(ref, [identifier, parameters].concat(slice.call(args), [done]));
    };

    DataMapper.prototype.remove = function() {
      var args, done, i, identifier, ref;
      identifier = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      identifier = this.convertObjectIdentifier(identifier);
      return (ref = this.tableGateway).remove.apply(ref, [identifier].concat(slice.call(args), [done]));
    };

    DataMapper.prototype.read = function() {
      var args, done, i, identifier, ref;
      identifier = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), done = arguments[i++];
      identifier = this.convertObjectIdentifier(identifier);
      return (ref = this.tableGateway).read.apply(ref, [identifier].concat(slice.call(args), [(function(_this) {
        return function(error, record) {
          if (error != null) {
            return done(error);
          }
          return done(null, _this.convertRecord(record));
        };
      })(this)]));
    };

    DataMapper.prototype.all = function() {
      var args, cursor, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      cursor = (ref = this.tableGateway).all.apply(ref, args);
      cursor.stream = cursor.stream.pipe(this.createTransformStream());
      return cursor;
    };

    return DataMapper;

  })();
  Cursor = (function() {
    Cursor.prototype.stream = null;

    function Cursor(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
    }

    Cursor.prototype.forEach = function(callback, done) {
      var writable, write;
      write = function(record, _, done) {
        return callback(record, done);
      };
      writable = new WritableStream({
        objectMode: true,
        write: write
      });
      writable.on("error", function(error) {
        return done(error);
      });
      writable.on("finish", function() {
        return done();
      });
      return this.stream.pipe(writable);
    };

    Cursor.prototype.toArray = function(done) {
      var pushRecord, records;
      records = [];
      pushRecord = function(record, done) {
        return done(null, records.push(record));
      };
      return this.forEach(pushRecord, function(error) {
        if (error) {
          return done(error);
        }
        return done(null, records);
      });
    };

    return Cursor;

  })();
  return BocoKnexRDB = {
    configure: configure,
    TableGateway: TableGateway,
    DataMapper: DataMapper,
    Cursor: Cursor,
    DataMapperObjectSourceMap: DataMapperObjectSourceMap,
    DataMapperRecordSourceMap: DataMapperRecordSourceMap
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
